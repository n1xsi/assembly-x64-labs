# Имя исполняемого файла
TARGET = main

# Ассемблер и компоновщик
AS = as
LD = ld

# Флаги ассемблера: -g добавляет отладочную информацию (для gdb).
ASFLAGS = -g

# Флаги компоновщика.
# -lc:                      Линкуемся со стандартной библиотекой C (для printf/scanf).
# -dynamic-linker ...:    Явно указываем программе-интерпретатору, который
#                           загружает динамические библиотеки. Необходимо при
#                           прямом вызове ld для программ, использующих libc.
LDFLAGS = -lc -dynamic-linker /lib64/ld-linux-x86-64.so.2

# Исходный и объектный файлы
SRCS = main.s
OBJS = $(SRCS:.s=.o)

# Цель по умолчанию: собрать всё.
# Эта цель зависит от исполняемого файла $(TARGET).
all: $(TARGET)

# Правило для создания исполняемого файла $(TARGET) из объектного файла $(OBJS).
# $@ - автоматическая переменная, означающая имя цели (здесь: 'main').
# $^ - автоматическая переменная, означающая имена всех зависимостей (здесь: 'main.o').
$(TARGET): $(OBJS)
	$(LD) $(LDFLAGS) -o $@ $^

# Правило для ассемблирования исходного файла (.s) в объектный (.o).
# $< - автоматическая переменная, означающая имя первой зависимости (здесь: 'main.s').
%.o: %.s
	$(AS) $(ASFLAGS) -o $@ $<

# Цель для запуска программы.
# Сначала собирает программу (зависимость 'all'), затем запускает.
run: all
	./$(TARGET)

# Цель для очистки скомпилированных файлов.
clean:
	rm -f $(OBJS) $(TARGET)

# Объявляем цели, которые не являются файлами, чтобы make не искал их.
.PHONY: all run clean
