# Лабораторная работа №5: Анализ байтов числа.
# Задание: Определить, составляют ли 8 байтов числа X арифметическую прогрессию.

### Определение точки входа в программу
.global _start

### Секция данных (константы)
.data
    # Исходное 64-битное число X (раскомментировать для разных вариантов тестирования)
    X: .quad 0x0706050403020100 # Прогрессия (d=1, убывающая)
    # X: .quad 0x0808080808080808 # Прогрессия (d=0)
    # X: .quad 0x0102040810204080 # НЕ прогрессия

    # Строки для вывода результатов
    initial_fmt: .asciz "Initial X: %ld (bytes: 0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx 0x%02hhx)\n"
    yes_fmt: .asciz "Result: The bytes of X form an arithmetic progression.\n"
    no_fmt:  .asciz "Result: The bytes of X DO NOT form an arithmetic progression.\n"

### Секция кода
.text

## Точка входа в программу
_start:
    ## Подготовка к выводу исходного числа и его байтов
    
    # Сохранение оригинального значения X в rbx для последующей обработки
    movq X(%rip), %rbx

    # Подготовка аргументов для printf согласно ABI x86-64 Linux:
    # Arg 1 (формат): %rdi
    # Arg 2 (число):  %rsi
    # Args 3-6:       %rdx, %rcx, %r8, %r9
    # Args 7+:        на стеке (в обратном порядке)

    leaq initial_fmt(%rip), %rdi    # Аргумент 1: адрес форматной строки
    movq %rbx, %rsi                 # Аргумент 2: само число X

    # Извлечение байтов для передачи в printf
    movq %rbx, %r11 # %r11 - временный регистр, чтобы не "портить" %rbx
    
    # Извлечение байтов с 0 по 7 последовательными сдвигами
    movb %r11b, %dl ; shrq $8, %r11  # Байт 0
    movb %r11b, %cl ; shrq $8, %r11  # Байт 1
    movb %r11b, %r8b; shrq $8, %r11  # Байт 2
    movb %r11b, %r9b; shrq $8, %r11  # Байт 3
    
    # Байты для стека извлекаем во временные регистры
    movq %r11, %r10 ; movb %r10b, %r10b ; shrq $8, %r10  # Байт 4
    movq %r10, %r12 ; movb %r12b, %r12b ; shrq $8, %r12  # Байт 5
    movq %r12, %r13 ; movb %r13b, %r13b ; shrq $8, %r13  # Байт 6
    movb %r13b, %r14b                                    # Байт 7

    # Перемещение байтов 0-3 в полные регистры
    # Т.к. printf ожидает аргументы полного размера (int/long), то передача 8 бит может вызвать проблемы
    # на некоторых системах/версиях libc, поэтому необходимо расширить байт нулями до 64 бит перед передачей
    movzbq %dl, %rdx  # movzbq - Move with Zero-Extend Byte to Quadword
    movzbq %cl, %rcx
    movzbq %r8b, %r8
    movzbq %r9b, %r9

    # Помещение байтов 7, 6, 5, 4 на стек (в обратном порядке) с выравниванием (расширением до 64 бит)
    movzbq %r14b, %r14; pushq %r14  # Аргумент 10 (байт 7)
    movzbq %r13b, %r13; pushq %r13  # Аргумент 9 (байт 6)
    movzbq %r12b, %r12; pushq %r12  # Аргумент 8 (байт 5)
    movzbq %r10b, %r10; pushq %r10  # Аргумент 7 (байт 4)

    xorq %rax, %rax                 # Обнуление rax перед вызовом printf
    call printf
    addq $32, %rsp                  # Очистка стека от 4-х аргументов (4 * 8 байт/аргумент = 32 байта)

    ## Проверка на арифметическую прогрессию

    # Извлечение байтов без изменения rbx, используя сдвиги на копии
    movq X(%rip), %rax              # Загрузка копии X в %rax
    movb %al, %r10b                 # Байт 0 (b0) -> r10b (предыдущий, первый байт)
    shrq $8, %rax                   # Сдвиг для доступа к следующему байту
    movb %al, %r11b                 # Байт 1 (b1) -> r11b (текущий, второй байт)

    # Вычисление эталонной разности (d = b_1 - b_0)
    # Т.к. байты - беззнаковые, используем регистры для знаковой арифметики
    movsxb %r11b, %r12              # Знаковое расширение b_1 до 64 бит
    movsxb %r10b, %r13              # Знаковое расширение b_0 до 64 бит
    subq %r13, %r12                 # r12 = b_1 - b_0 (результат d)

    # Подготовка к циклу
    movb %r11b, %r10b               # r10b теперь хранит "предыдущий" байт (b1)
    movq $6, %rcx                   # Счётчик цикла: осталось проверить 6 пар (b2-b1, b3-b2, ..., b7-b6)

## Проверка, не закончился ли цикл
check_loop:
    testq %rcx, %rcx                # Проверка rcx на ноль
    jz is_arithmetic                # Если счётчик (rcx) = 0, все пары совпали -> прогрессия и переход к выводу "да" (jz - jump if zero)

    shrq $8, %rax                   # Сдвигаем число для доступа к следующему байту
    movb %al, %r11b                 # r11b = b_i (текущий байт)

    # Вычисление текущей разности: diff = b_i - b_{i-1}
    movsxb %r11b, %r13              # Знаковое расширение b_i
    movsxb %r10b, %r14              # Знаковое расширение b_{i-1}
    subq %r14, %r13                 # r13 = b_i - b_{i-1}

    # Сравнивание текущей разности с эталонной (ожидаемой)
    cmpq %r12, %r13
    jne not_arithmetic              # Если не равны, прогрессии нет и и переход к выводу "нет" (jne - jump if not equal)

    # Если равны, то подготовка к следующей итерации
    movb %r11b, %r10b               # Текущий байт становится "предыдущим"
    decq %rcx                       # Уменьшение счётчика циклов (dec - decrement)
    jmp check_loop                  # Переход к следующей итерации

## Если цикл завершился успешно, значит это арифметическая прогрессия
is_arithmetic:
    leaq yes_fmt(%rip), %rdi  # Загрузка адреса строки "Да" в rdi
    xorq %rax, %rax           # Обнуление rax для printf
    call printf               # Вызов printf
    jmp exit_program          # Переход к завершению программы

## Если была найдена несовпадающая разность
not_arithmetic:
    leaq no_fmt(%rip), %rdi  # Загрузка адреса строки "Нет" в rdi
    xorq %rax, %rax
    call printf
    # Нет необходимости в jmp, выполнение перейдет к exit_program

## Завершение программы
exit_program:
    movq $60, %rax                  # Системный вызов sys_exit
    xorq %rdi, %rdi                 # Код возврата 0 (успех)
    syscall                         # Завершение процесса

