# Лабораторная работа №4: Поразрядная обработка данных.
# Задание: В 64-битном числе X поменять пары двоичных разрядов в зеркальном порядке.

### Определение точки входа в программу
.global _start

### Секция данных (константы)
.data
    input_X: .quad 16  # Исходное число X

    # Строки для форматированного вывода
    output_original_str: .asciz "Original number X: %ld (binary: %s)\n"  # %ld - long decimal, %s - двоичная строка (string)
    output_result_str:   .asciz "Result:            %ld (binary: %s)\n"

    binary_buffer: .space 65  # Буфер для хранения двоичного представления числа (64 бита + 1 нулевой символ)

### Секция кода
.text

## Функция для преобразования 64-битного числа в двоичную строку
# Вход:
#   %rdi - число для преобразования
#   %rsi - указатель на буфер для записи строки
# Выход:
#   Строка в буфере, на который указывает %rsi, завершённая нулевым символом
to_binary:
    # Сохранение регистров, которые нужно будет использовать
    pushq %rax  # pushq - push quadword onto stack
    pushq %rcx
    pushq %rdx
    pushq %rdi  # Сохранение оригинала числа

    movq $64, %rcx              # Инициализация счётчика цикла для 64 бит
    movq %rdi, %rax             # Копирование числа в %rax для манипуляций
    movq %rsi, %rdx             # %rdx будет указателем на текущую позицию буфера

convert_loop:
    # Проверка старшего бита числа в %rax
    # Использование сдвига влево на 1, чтобы перенести старший бит в флаг переноса (CF)
    shlq $1, %rax  # shlq - shift logical left quadword

    # Условная запись в буфер '1' или '0' в зависимости от флага переноса
    jnc bit_is_zero             # Если флаг переноса (CF) не установлен (бит был 0, CF=0), переход к bit_is_zero
                                # jnc - Jump if Not Carry
    movb $'1', (%rdx)           # Иначе (бит был 1, CF=1), запись байта '1' в буфер
                                # movb - move byte
    jmp next_bit

bit_is_zero:
    movb $'0', (%rdx)           # Запись байта '0' в буфер

next_bit:
    incq %rdx                   # Перемещение указателя на следующий символ в буфере
    loop convert_loop           # Уменьшает %rcx (на 1) и, если он не 0, переходит к convert_loop
                                # loop - loop according to count register

    movb $0, (%rdx)             # Добавление нулевого символа в конец строки

    # Восстановление сохранённых регистров в обратном порядке
    popq %rdi                   # popq - pop quadword from stack
    popq %rdx
    popq %rcx
    popq %rax
    ret                         # Возврат из функции (ret - return from procedure)

## Точка входа в программу
_start:
    # Вывод исходного числа
    movq input_X(%rip), %rbx    # Загрузка X в %rbx

    # Преобразование исходного числа в двоичную строку
    movq %rbx, %rdi                 # Аргумент 1 для to_binary: число
    leaq binary_buffer(%rip), %rsi  # Аргумент 2: адрес буфера
    call to_binary

    # Вывод исходного числа и его двоичного представления
    leaq output_original_str(%rip), %rdi  # Аргумент 1 для printf: форматная строка
    movq %rbx, %rsi                       # Аргумент 2: число X
    leaq binary_buffer(%rip), %rdx        # Аргумент 3: двоичная строка
    xorq %rax, %rax                       # %rax=0 для variadic-функций
    call printf

    # Поразрядная обработка: смена пар битов местами
    # 1. Выделить все биты на нечётных позициях (1, 3, 5, ..., 63) с помощью маски 0xAAAAAAAAAAAAAAAA
    # 2. Выделить все биты на чётных позициях (0, 2, 4, ..., 62) с помощью маски 0x5555555555555555
    # 3. Сдвинуть нечётные биты на одну позицию вправо (становятся на чётные позиции)
    # 4. Сдвинуть чётные биты на одну позицию влево (становятся на нечётные позиции)
    # 5. Объединить результаты с помощью побитового ИЛИ (OR)

    movq %rbx, %rax                 # Копирование X в %rax для обработки
    movq %rax, %r10                 # Сохранение копии в %r10 (для 2-го шага)

    # Шаги 1 и 3: Работа с нечётными битами
    movq $0xAAAAAAAAAAAAAAAA, %r11  # Маска для выделения нечётных битов (10101010...)
    andq %r11, %rax                 # Оставляем в %rax только нечётные биты из X (andq - logical AND quadword)
    shrq $1, %rax                   # Их сдвиг вправо на 1 позицию (shrq - shift logical right quadword)

    # Шаги 2 и 4: Работа с чётными битами
    movq $0x5555555555555555, %r11  # Маска для выделения чётных битов (01010101...)
    andq %r11, %r10                 # Оставляем в %r10 только чётные биты из X
    shlq $1, %r10                   # Их сдвиг влево на 1 позицию

    # Шаг 5: Объединение результатов
    orq %r10, %rax                  # Складываем результаты: т.к. биты не пересекаются, OR работает как простое объединение
                                    # %rax теперь содержит итоговое число
                                    # orq - logical inclusive OR quadword

    movq %rax, %rbx                 # Сохранение результата в %rbx

    # Вывод результата (с преобразованием числа в двоичную строку)
    movq %rbx, %rdi
    leaq binary_buffer(%rip), %rsi
    call to_binary

    # Вывод результата и его двоичного представления
    leaq output_result_str(%rip), %rdi
    movq %rbx, %rsi
    leaq binary_buffer(%rip), %rdx
    xorq %rax, %rax
    call printf

    # Завершение программы
    addq $8, %rsp                   # Восстанавление стека
    movq $60, %rax                  # Системный вызов sys_exit
    xorq %rdi, %rdi                 # Код возврата 0 (успех)
    syscall                         # Завершение процесса
